# All about list...
# List is a data type...
# Strings and lists are both examples of sequences...
# [] are used for its indication...

list1=["I","am","loving","programming"]
print(type(list1))

# Length of the list is how many elements it has...
# Length os elements doesn't matter, what matters is no. of elements...
print("Length of the string is:",len(list1))

# Use of keyword "in"...
print("am" in list1)        # Result is boolean, that can be used for condition check...

# 0 to n-1 is the values of the places...
print(list1[2])             # The elements of the list can be accessed in this way...

# Slicing of the list can be done here too...
print(list1[0:3])            # please take care slicing will go till n-1...

print(list1[1:])
print(list1[:3])              # When nothing is given as index value that means complete length...

print(list1[-1])            # Acessing the list from the last...

# Concatination is also allowed here...
list2=list1[:3]+["Nothing"]
print(list2)

# Many of the functions that we perform are quite common in both lists and strings...
# But, lists are "mutable"...i.e they can be changed.
# This means we can add, remove and modify item from a list...

# adding a element in the list...using the the method, append...
list3=["cars","bike","bicycle"]
print(list3)
list3.append("truck")
print(list3)

# "insert" method to add elements in a list at "any position"...
list3.insert(0,"vehicles")      # 0 is the position...that means index...
print(list3)

# The list are quite smarter...if we insert the element at index far more than the last value that exist,...
# then the list adds it at the end of the list, instead of making any error...
list3.insert(100,"done")
print(list3)

# to remove the element from the list we use the "remove" method...
list3.remove("done")
print(list3)

# remove using an index, "pop" method...
list3.pop(0)                # here, 0 is the index of the element to be removed...
print(list3)

# to change the content of the list we have...
list3[2]="cycle"
print(list3)

# this property of list i.e. "mutable" is very crutial in the real life application...
# like, if we want to make the user data base that are coming online, then...
# they can be added or removed according to the availibility of the users...

# Rest many of the methods that were present in strings also remain same here...

# Tuples are the sequences of elements of any type, that are immutable...
# Lists are the sequences of elements of any type, that are mutable...
# Strings are the sequences of characters and are immutable...

# Tuples...
tuple1=("I","want","to","be","the","programmer","in","the","world")
print(type(tuple1))
print(tuple1)

# Hey, but why do we need tuples when list is there...
# There are specific places where we want an element at a specific position,
# and we desire that this element should not be changed...
full_name=("Mohit","Kumar","Rohilla")
# The position of the elements inside tuple have meaning...i.e. order matters.
# When a function returns more than 1 value then actually, its returning a tuple...

# tuples are useful in the cases where it need to be kept together...

# iterating over list and tuples...
animals=["cat","dog","elephant","tiger"]
print("List is:",animals)
char=0
for animal in animals:
    char+=len(animal)
print("Total characters: {}, Average length: {}".format(char,char/len(animals)))

# Enumerate function...
for index, ani in enumerate(animals):
    print("{}-{}".format(index+1,ani))
# enumerate function returns a tuple for each element in a list...
# here, 1st value in the tuple is the "index of element" in seq, 2nd value is "element" in seq...

def full_emails(people):
    result=[]
    for email,name in people:
        result.append("{}<{}>".format(name,email))
    return result
print(full_emails([("awesomeprogrammer@gmail.com","Programmer"),
                   ("rohillam@gmail.com","M Rohilla"),
                   ("rakeshyadav@gmail.com","Rakesh Yadav")]))


# When ever doing experiments with the list make a habbit of doing it with the copy of the original list...
# since, list are mutable, any changes we do will be reflected always...
# iterate through the elements of list, or by using the enumerate function, don't make a habbit of doing...
# the iteration via index number...its fine with other languages, but, python offers good alternatives...

# more about the lists...
# if we need to make a list of multiples of 7...
multiples=[]
for var in range(1,11):
    multiples.append(var*7)
print(multiples)

# List comprehension
multiples_1=[x*7 for  x in range(1,11)]
print(multiples_1)
# list comprehension lets us create new lists based  on sequences and ranges...

lang=["we","are","python","lover"]
lengths=[len(language) for language in lang]        # for loop single line...
print(lengths)

z=[x for x in range(1,51) if x%3==0]                    # if condition check single line...
print(z)



    


